#!/usr/bin/env bash

SUPPORT_FIRECLOUD_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
source ${SUPPORT_FIRECLOUD_DIR}/sh/common.inc.sh

[[ "$1" != "debug" ]] || {
    echo
    echo "  Creating a debugging subshell..."
    echo
    PS1="${debian_chroot:+($debian_chroot)}\u:\w\$ " ${SHELL}
    exit 0
}


# github action checkout
function sf_ga_checkout() {
    cd ${GITHUB_WORKSPACE}
    GIT_BRANCH=
    GIT_CLONE_BRANCH_ARG=
    if [[ "${GITHUB_REF:-}" =~ "^refs/heads/" ]]; then
        GIT_BRANCH=${GITHUB_REF#refs\/heads\/}
        GIT_CLONE_BRANCH_ARG="--branch=${GIT_BRANCH}"
    fi
    git clone --depth=50 ${GIT_CLONE_BRANCH_ARG} git@github.com:${GITHUB_REPOSITORY}.git
    cd $(basename ${GITHUB_REPOSITORY})
    [[ -z "${GIT_BRANCH}" ]] || {
        git checkout -B ${GIT_BRANCH}
    }
    git reset --hard ${GITHUB_SHA}
    git submodule update --init --recursive
}


function sf_rvm_unfuck() {
    # from https://github.com/matthew-brett/multibuild/blob/34b988aab60a93fa3c7bd1eb88dd7c4361ca464f/common_utils.sh#L17

    # Work round bug in travis xcode image described at
    # https://github.com/direnv/direnv/issues/210
    shell_session_update() { :; }

    # Workaround for https://github.com/travis-ci/travis-ci/issues/8703
    # suggested by Thomas K at
    # https://github.com/travis-ci/travis-ci/issues/8703#issuecomment-347881274
    unset -f cd
    unset -f pushd
    unset -f popd
}
sf_rvm_unfuck


function sf_private_submodules() {
    [[ -z "${GH_TOKEN:-}" ]] || {
        echo_do "Found GH_TOKEN, setting up github.com HTTPS authentication..."
        echo -e "machine github.com\n  login ${GH_TOKEN}" >> ~/.netrc

        # cover git submodules's canonical ssh url
        git config --global url.https://github.com/tobiipro/.insteadOf git@github.com:tobiipro/
        # cover npm package.json's canonical git+ssh url
        git config --global url.https://github.com/tobiipro/.insteadOf ssh://git@github.com/tobiipro/
        echo_done
    }
}


function sf_transcrypt() {
    # de-transcrypt only for non-PRs or for PRs from the same repo
    [[ "${CI_IS_PR:-}" != "true" ]] || {
        [[ "${CI_PR_SLUG}" = "${CI_REPO_SLUG}" ]] || return 0
    }
    [[ -x "./transcrypt" ]] || return 0
    [[ -n "${TRANSCRYPT_PASSWORD:-}" ]] || return 0

    if git config --local transcrypted.version >/dev/null; then
        echo_skip "${FUNCNAME[0]}: Repository isn't transcrypted..."
        return 0
    fi

    echo_do "Found TRANSCRYPT_PASSWORD, setting up transcrypt..."
    ./transcrypt -y -c aes-256-cbc -p "${TRANSCRYPT_PASSWORD}"
    unset TRANSCRYPT_PASSWORD
    echo_done
}


function sf_pyenv_init() {
    if which pyenv >/dev/null 2>&1; then
        eval "$(pyenv init -)"
    fi
}


function sf_run_docker() {
    SF_TRAVIS_DOCKER_IMAGE=${1}

    echo_do "Spinning up Docker for ${SF_TRAVIS_DOCKER_IMAGE}..."

    # pull docker image
    exe docker pull ${SF_TRAVIS_DOCKER_IMAGE}

    # run the docker container, while passing relevant env vars and mounting HOME folder
    exe docker run -d -it --rm \
        --name docker-ci \
        --env CI=true \
        --env-file <(cat ~/build.sh | \
                         grep --only-matching "^travis_cmd export\\\\ [^ ]\+" | \
                         sed "s/travis_cmd export\\\\ //g" | \
                         xargs -L1 echo) \
        --env-file <(printenv | grep -e "^TRAVIS") \
        --volume ${HOME}:${HOME} \
        ${SF_TRAVIS_DOCKER_IMAGE}

    exe docker exec -it -u root docker-ci \
        touch /support-firecloud.docker-ci

    # create same groups (and gids) that the 'travis' user belongs to inside the docker container
    for GROUP_ID in $(id -G); do
        exe docker exec -it -u root docker-ci \
            addgroup \
            --gid ${GROUP_ID} \
            $(getent group ${GROUP_ID} | cut -d: -f1) || true;
    done

    # create same user (and uid) that the 'travis' user has inside the docker container
    exe docker exec -it -u root docker-ci \
        adduser \
        --uid $(id -u) \
        --ingroup $(id -g --name) \
        --home /home/$(id -u --name) \
        --shell /bin/sh \
        --disabled-password \
        --gecos "" \
        $(id -u --name)

    # add the 'travis' user to the groups inside the docker container
    for GROUP_ID in $(id -G) $(getent group sudo | cut -d: -f3); do
        exe docker exec -it -u root docker-ci \
            adduser \
            $(id -u --name) \
            $(getent group ${GROUP_ID} | cut -d: -f1);
    done

    # the 'travis' user needs to own /home/linuxbrew in order to run linuxbrew successfully
    exe docker exec -it -u root docker-ci \
        chown -R $(id -u):$(id -g) /home/linuxbrew

    echo_done
}


function sf_os() {
    [[ "${SF_FORCE_BOOTSTRAP:-}" = "true" ]] || {
        [[ ! -d /support-firecloud.bootstrapped ]] || {
            echo_info "${FUNCNAME[0]}: /support-firecloud.bootstrapped exists."
            echo_info "${FUNCNAME[0]}: Assumming that OS is already bootstrapped (Docker image)."
            return 0
        }
    }

    [[ "${CI_DEBUG_MODE:-}" != "true" ]] || {
        SF_LOG_BOOTSTRAP=${SF_LOG_BOOTSTRAP:-true}
    }
    echo_info "${FUNCNAME[0]}: Running with SF_LOG_BOOTSTRAP=${SF_LOG_BOOTSTRAP:-}"

    local BOOTSTRAP_SCRIPT="${SUPPORT_FIRECLOUD_DIR}/ci/${OS_SHORT}/bootstrap"

    if [[ "${SF_LOG_BOOTSTRAP:-}" = "true" ]]; then
        ${BOOTSTRAP_SCRIPT}
        return 0
    fi

    local TMP_SF_OS_LOG=$(mktemp)
    echo_info "${FUNCNAME[0]}: Redirecting into ${TMP_SF_OS_LOG} to minimize CI log..."

    echo " 0 1 2 3 4 5 6 7 8 9101112131415 min"
    while :;do echo -n " ."; sleep 60; done &
    local WHILE_LOOP_PID=$!
    trap "kill ${WHILE_LOOP_PID}" EXIT
    ${BOOTSTRAP_SCRIPT} >${TMP_SF_OS_LOG} 2>&1 || {
        echo
        echo_err "${FUNCNAME[0]}: Failed. The latest log tail follows:"
        tail -n1000 ${TMP_SF_OS_LOG}
        sleep 10 # see https://github.com/travis-ci/travis-ci/issues/6018
        return 1
    }
    echo
    kill ${WHILE_LOOP_PID} && trap " " EXIT
}


function sf_ci_run() {
    >&2 echo "$(date +"%H:%M:%S") [DO  ] $@"

    CMD=
    if [[ "$(type -t "ci_run_${1}")" = "function" ]]; then
        CMD="ci_run_${1}"
    elif [[ "$(type -t "sf_ci_run_${1}")" = "function" ]]; then
        CMD="sf_ci_run_${1}"
    else
        >&2 echo "$(date +"%H:%M:%S") [INFO] Couldn't find a ci_run_${1} or sf_ci_run_${1} function."

        >&2 echo "$(date +"%H:%M:%S") [DONE] $@"
        return 0
    fi

    if [[ "${TRAVIS:-}" != "true" ]]; then
        true
    elif [[ -f /support-firecloud.docker-ci ]]; then
        echo_info "Running inside the docker-ci container."
    elif [[ "${OS_SHORT:-}" != "linux" ]]; then
        echo_info "Skipping the docker-ci container because the host OS is not linux."
    elif [[ "${SF_TRAVIS_DOCKER_IMAGE:-}" = "false" ]]; then
        echo_info "Skipping the docker-ci container because viaSF_TRAVIS_DOCKER_IMAGE=false."
    else
        CMD="exe docker exec -it -w ${TRAVIS_BUILD_DIR} -u $(id -u):$(id -g) docker-ci ${0} $@"

        if [[ "${1}" = "before_install" ]]; then
            if [[ -z "${SF_TRAVIS_DOCKER_IMAGE:-}" ]]; then
                RELEASE_ID=$(source /etc/os-release && echo ${ID})
                RELEASE_VERSION_CODENAME=$(source /etc/os-release && echo ${VERSION_CODENAME})
                SF_TRAVIS_DOCKER_IMAGE=tobiipro/sf-${RELEASE_ID}-${RELEASE_VERSION_CODENAME}-minimal
            fi
            # if given a tobiipro/sf- image, but without a tag, set the tag to the hash of SF
            if [[ "${SF_TRAVIS_DOCKER_IMAGE}" =~ "^tobiipro\/sf-" ]] && [[ ! "${SF_TRAVIS_DOCKER_IMAGE}" =~ /:/ ]]; then
                SF_HASH_SHORT=$(cd ${SUPPORT_FIRECLOUD_DIR} && git rev-parse --short HEAD 2>/dev/null)
                SF_TRAVIS_DOCKER_IMAGE="${SF_TRAVIS_DOCKER_IMAGE}:${SF_HASH_SHORT}"
            fi

            sf_run_docker ${SF_TRAVIS_DOCKER_IMAGE}
        fi
    fi

    eval "${CMD}"

    >&2 echo "$(date +"%H:%M:%S") [DONE] $@"
}


function sf_ci_run_before_install() {
    sf_private_submodules
    sf_transcrypt
    sf_os
    sf_pyenv_init

    [[ "${CI_DEBUG_MODE:-}" != "true" ]] || {
        echo
        echo "  Please run \`./.ci.sh debug\` to activate your debug session !!!"
        echo
    }
}


function sf_ci_run_install() {
    make deps
}


function sf_ci_run_script() {
    make all test
}


function sf_ci_run_before_deploy() {
    make snapshot
    make dist
}


function sf_ci_run_after_script_upload_job_artifacts() {
    [[ -f .artifacts ]] || {
        echo_skip "${FUNCNAME[0]}: No .artifacts found..."
        return 0
    }

    [[ -n "${GH_TOKEN:-}" ]] || {
        echo_skip "${FUNCNAME[0]}: No GH_TOKEN found..."
        return 0
    }

    echo_do "Uploading job artifacts..."

    local JOB_GIT_REF=refs/jobs/${CI_JOB_ID}

    git checkout --orphan jobs/${CI_JOB_ID}
    git ls-files -- "*/.gitignore" | xargs -L1 rm -f
    git reset -- .
    cat .artifacts | xargs -L1 git add -f || true

    [[ "${TRAVIS:-}" != "true" ]] || {
        # (Try to) Create log.sh-session
        local CURL_TRAVIS_API_HEADERS=(-H "Travis-API-Version: 3")
        [[ -z "${TRAVIS_API_TOKEN:-}" ]] || {
            CURL_TRAVIS_API_HEADERS+=(-H "Authorization: token ${TRAVIS_API_TOKEN}")
        }
        touch log.sh-session
        curl \
            -sS \
            "${CURL_TRAVIS_API_HEADERS[@]}" \
            https://api.travis-ci.com/job/${TRAVIS_JOB_ID}/log | jq -r '.content' >log.sh-session || true
        git add -f log.sh-session
    }

    # Create README.md
    cat <<-EOF >README.md
${JOB_GIT_REF}

# Job [${CI_JOB_ID}](${CI_JOB_URL})

## Artifacts

$(git ls-files | xargs -I {} echo "* [{}]({})")

EOF
    git add -f README.md

    git commit -m "${CI_JOB_ID}"
    local JOB_GIT_HASH=$(git rev-parse HEAD)

    # Upload to git refs/job/<job_id>
    git push --no-verify -f https://${GH_TOKEN}@github.com/${CI_REPO_SLUG}.git HEAD:${JOB_GIT_REF} || true

    git checkout -f -

    echo_done

    local JOB_GITHUB_UI_URL=https://github.com/${CI_REPO_SLUG}/tree/${JOB_GIT_HASH}
    echo_info "View job artifacts on Github: ${JOB_GITHUB_UI_URL}"

    # (Try to) Remove job artifacts older than 7 days ago
    function prune_job_git_ref() {
        local JOB_GIT_REF=$1
        git fetch --depth=1 origin ${JOB_GIT_REF} >/dev/null 2>&1
        [[ -z $(git log -1 --since='7 days ago' FETCH_HEAD) ]] || return 0
        echo_info "Deleting ${JOB_GIT_REF}..."
        git push --no-verify -f origin :${JOB_GIT_REF} >/dev/null 2>&1
    }
    while read -u3 JOB_GIT_REF; do
        prune_job_git_ref ${JOB_GIT_REF} || true
    done 3< <(git ls-remote origin "refs/jobs/*" | cut -f2)
}


function sf_ci_run_after_script() {
    sf_ci_run_after_script_upload_job_artifacts
}


function sf_ci_run_notifications_slack() {
    [[ -n "${SLACK_WEBHOOK:-}" ]] || return 0
    [[ "${CI_STATUS:-}" = "failure" ]] || return 0

    ${SUPPORT_FIRECLOUD_DIR}/bin/slack-echo \
        "Build #ID (${GIT_HASH_SHORT}) of ${CI_REPO_SLUG}@${GIT_BRANCH:-${CI_TAG}} \
        by $(git log -1 --pretty=format:%cn) \
        failed"
}

function sf_ci_run_notifications() {
    sf_ci_run_notifications_slack
}


function sf_ci_run_before_cache_brew() {
    which brew >/dev/null 2>&1 || return 0
    local HOMEBREW_PREFIX=$(brew --prefix)
    local CI_CACHE_HOMEBREW_PREFIX
    brew cleanup

    case $(uname -s) in
        Darwin)
            CI_CACHE_HOMEBREW_PREFIX=~/.homebrew
            ;;
        Linux)
            CI_CACHE_HOMEBREW_PREFIX=~/.linuxbrew
            ;;
        *)
            echo_err "${FUNCNAME[0]}: $(uname -s) is an unsupported OS."
            return 1
            ;;
    esac

    local HOMEBREW_PREFIX_FULL=$(cd ${HOMEBREW_PREFIX} 2>/dev/null && pwd || true)
    local CI_CACHE_HOMEBREW_PREFIX_FULL=$(cd ${CI_CACHE_HOMEBREW_PREFIX} 2>/dev/null && pwd || true)
    if [[ "${HOMEBREW_PREFIX_FULL}" = "${CI_CACHE_HOMEBREW_PREFIX_FULL}" ]]; then
        return 0
    fi

    echo_do "brew: Caching ${HOMEBREW_PREFIX}/Homebrew..."
    mkdir -p ${CI_CACHE_HOMEBREW_PREFIX}/Homebrew
    rsync -aW --inplace --delete \
        ${HOMEBREW_PREFIX}/Homebrew/ \
        ${CI_CACHE_HOMEBREW_PREFIX}/Homebrew/
    echo_done

    # FIXME remove after 2019-03-01
    rm -rf ${CI_CACHE_HOMEBREW_PREFIX}/Cellar/*
}


function sf_ci_run_before_cache_stats() {
    echo_do "Showing cache stats..."

    [[ "${TRAVIS:-}" != "true" ]] || {
        local YAML2JSON="ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))'"
        for f in $(eval "${YAML2JSON} .travis.yml" | jq -r ".cache.directories[]"); do
            eval "f=${f}"
            [[ -d "${f}" ]] || continue
            du -hcs ${f} | head -n+1
        done
    }

    echo_done
}


function sf_ci_run_before_cache() {
    sf_ci_run_before_cache_brew
    sf_ci_run_before_cache_stats || true
}


function sf_ci_run_all() {
    local CI_PHASES="$(cat <<-EOF
before_install
install
before_script
script
EOF
)"

    for f in ${CI_PHASES}; do
        sf_ci_run $f;
    done
}


[[ "${TRAVIS:-}" != "true" ]] || {
    git config --global user.email "travis@travis-ci.org"
    git config --global user.name "Travis CI"

    CI_DEBUG_MODE=${TRAVIS_DEBUG_MODE:-}
    CI_JOB_ID=${TRAVIS_JOB_ID}
    CI_JOB_URL=${TRAVIS_JOB_WEB_URL}
    CI_PR_SLUG=${TRAVIS_PULL_REQUEST_SLUG:-}
    CI_REPO_SLUG=${TRAVIS_REPO_SLUG}
    CI_IS_PR=false
    if [[ "${TRAVIS_EVENT_TYPE}" = "pull_request" ]]; then
        CI_IS_PR=true
    fi
    CI_IS_CRON=false
    if [[ "${TRAVIS_EVENT_TYPE}" = "cron" ]]; then
        CI_IS_CRON=true
    fi
    CI_TAG=${TRAVIS_TAG:-}
}

[[ "${CIRCLECI:-}" != "true" ]] || {
    git config --global user.email "circleci@circleci.com"
    git config --global user.name "CircleCI"

    CI_DEBUG_MODE=${CI_DEBUG_MODE:-}
    CI_JOB_ID=${CIRCLE_WORKFLOW_JOB_ID}
    CI_JOB_URL=https://circleci.com/workflow-run/${CIRCLE_WORKFLOW_ID}
    CI_PR_SLUG=${CIRCLE_PR_USERNAME:-}/${CIRCLE_PR_REPONAME:-}
    CI_REPO_SLUG=${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}
    CI_IS_PR=false
    if [[ -n "${CIRCLE_PR_NUMBER:-}" || -n "${CIRCLE_PULL_REQUEST:-}" ]]; then
        CI_IS_PR=true
    fi
    CI_IS_CRON=${CI_IS_CRON:-} # needs to come from .circleci/config.yml
    CI_TAG=${CIRCLE_TAG:-}
    export USER=$(whoami)
}

[[ "${GITHUB_ACTIONS:-}" != "true" ]] || {
    git config --global user.email "actions@github.com"
    git config --global user.name "Github Actions CI"

    CI_DEBUG_MODE=${CI_DEBUG_MODE:-}
    CI_JOB_ID=${GITHUB_ACTION}
    CI_JOB_URL=https://github.com/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks?check_suite_id=FIXME
    CI_PR_SLUG=
    if [[ "${GITHUB_EVENT_NAME}" = "pull_request" ]]; then
        CI_PR_SLUG=https://github.com/${GITHUB_REPOSITORY}/pull/$(jq -r .github.event.number ${GITHUB_EVENT_PATH})
    fi
    CI_REPO_SLUG=${GITHUB_REPOSITORY}
    CI_IS_PR=false
    if [[ "${GITHUB_EVENT_NAME}" = "pull_request" ]]; then
        CI_IS_PR=true
    fi
    CI_IS_CRON=false
    if [[ "${GITHUB_EVENT_NAME}" = "" ]]; then
        CI_IS_PR=true
    fi
    CI_TAG=
    if [[ "${GITHUB_REF:-}" =~ "^refs/tags/" ]]; then
        CI_TAG=${GITHUB_REF#refs\/tags\/}
    fi
    export CI=true
}

[[ -z "$*" ]] || sf_ci_run $@
